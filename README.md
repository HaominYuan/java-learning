# 题目和答案均来源于互联网。
- - -
### Java跨平台的特点是怎么体现的？
* 源程序.java 经过编译以后生成 字节码.class。字节码.class 被JVM虚拟机执行。
* JVM虚拟机是与平台相关的，不同的平台需要不同的jvm虚拟机。
- - -
### 编译语言和解释语言的区别？
* 编译语言是直接将整个程序进行编译成为机器语言后执行。
* 解释语言是一句一句的解释然后执行。
- - -
### Java类中的静态变量是什么时候初始化的？
* 一个类要被时候需要经过装载、连接和初始化这三个过程。
* 在装载阶段，类装在器把编译形成的Class文件载入内存，创建类相关的Class对象，这个Class对象封装了我们要使用的类的类型信息。
* 连接又可以分为三个子步骤：验证、准备和解析。
  * 验证就是要确保Java类型数据格式的正确性，并适用于JVM使用。
  * 准备阶段，JVM为静态变量分配内存空间，并设置默认值，注意，这里是默认值，比如整型的变量会被赋予默认值0。在这个阶段，JVM可能还会为一些数据结构分配内存，目的是提高运行程序的性能，比如方法表。
  * 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用。这个阶段可以被推迟到初始化之后，当程序运行的过程中真正使用某个符号引用的时候再去解析它。
* 类会在首次被_主动使用_时被初始化，为类（静态）变量赋予正确的初始值。在Java代码中，一个正确的初始化是通过类变量初始化语句或者静态初始化给出的。而我们这里所说的主动使用包括：
  * 创建类的实例
  * 调用类的静态方法
  * 使用类的非常量静态字段
  * 调用Java API中的某些反射方法
  * 初始化某个类的子类
  * 含有main()方法的类启动时
* 初始化一个类包括两个步骤：
  * 如果类存在直接父类且直接父类还没有被初始化，则先初始化其直接父类。
  * 如果类存在一个初始化方法，则执行此方法。
- - -
### Java异常体系简析
* 《Jva编程思想》对异常的描述：
  * 除非你能解决（或必须要处理）这个异常，否则不要捕获它，如果打算记录错误消息，那么别忘了把它再抛出去。
  * 异常即代表一种错误，又可以代表一个消息。
* 为什么会有异常？
  * 如果我们有一个函数是用来作除法的。除法操作是不能够除以零的。如果函数传入的分母是零，这时异常出现了。直接让程序挂掉了是不行，但函数自己并不能自己处理这种突发情况，所以得想办法把这种情况告诉用户，让用户自己来作决定，也就是说程序要把遇到的这种异常情况包装一下发送出去，由用户来做决定如何处理。
  * 异常表示着一种信息。例如EOFException
* Java异常的分类
  * Throwable类是所有异常的父类。Error类和Exception类继承于Throwable类。
  * Error类表示很严重的问题发生了，可以捕获但是不要捕获，因为捕获了并不能解决问题。这个不是由程序产出的，是底层出现了问题。
  * Exception类分为RuntimeException类和其他类
* 异常的处理的理解
   * 重复尝试解决偶发的问题。
     * 例如：当我我们于服务器建立了Socket连接，当长时间不用被服务器主动断开了连接，或者网络都懂导致的断开），那么我们捕获这个异常，然后重新建立一个连接来发送。这是最基本的解决方法，或者设置一个重复次数，当出现异常的时候重复发送指定的次数。
     * 上述的例子里面，这个连接异常我们没有真正的解决它，而是通过又新建一个连接来处理，我们的解决的不是异常问题，而是发送数据出现了问题，我们解决的是发送数据没有成功这个问题。
   * 不想让用户看到错误堆栈
     * 例如用户发送了请求，我们无法处理并导致了异常。如果不捕获异常，那么用户将会看到一个500页面，附带着堆栈信息，这种是不友好的表现方式。实际上我们会有一个最大的catch抱住一个个方法，当出现异常的情况跳转到错误页面。
     * 实际上我们并没有解决异常，我们只是继绝了异常导致的问题，异常本身还在那，真正的解决方法就是程序员极倔bug然后重新上线。
   * 我们应该怎么做
     * 就像简单的除零异常，以及字符串转数字异常，本身异常堆栈就会提供基本的信息，但是我如果在一个用户交互的环境下，加入我们想要知道是哪个用户的输入到导致了异常的产生，这个时候系统产生的异常堆栈信息就不能满足我们的要求。这个时候我们就要主动捕获异常个然后打印出我们想要的信息。
* 异常的处理
   * 对认为一定不会出现的异常，如果出现了异常那我们直接抛出Error类，表示应该立即停止程序并重启解决问题。
   * 对假定不应该出现的异常，抛出运行时异常。（抛出异常好像不需要写异常情况的return）
   * 对假定一定出现异常的情况。这种代码你也好意思写，你要脸吗？
* 异常的一些特殊情况
   * 防止异常丢失，当我们在finally的情况中写了return时，异常就会丢失。
   * 线程中ThreadDeath异常，这个异常出现时会终结线程。如果捕获了这个异常必须抛出，不然会导致本该死亡的线程继续运行下去。
- - -