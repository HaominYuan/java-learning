### 概述
  * 当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：
    * 哪些内存需要回收？
    * 什么时候回收？
    * 如何回收？
  * 在Java中，程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；这几个区域内就不需要过多考虑回收的问题。
  * Java堆和元空间这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。
### 对象已死吗
  * 引用计数算法
    * 思路：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就会减1；任何时刻计数器为0的对象就是不可能再被使用的。
    * 在主流的Java虚拟机里面没有选用引用计算算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
  * 可达性分析算法
    * 思路：通过一系列的称为“GC Roots”的对象做为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
    * 在Java语言中，可作为GC Roots的对象包括下面几种：
      * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
      * 元空间中类静态属性引用的对象。
      * 元空间中常量引用的对象。
      * 本地方法栈中JNI（即一般说的Native方法）引用对象。
  * 再谈引用
    * 引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。
      * 强引用就是指在程序中普遍存在的，类似“Object obj = new Object()"这类的引用，只要强引用存在，垃圾回收器永远不会回收掉被引用的对象。
      * 软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发出内存溢出异常之前，将会把这些对象列出回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出溢出异常。
      * 弱引用也是用来描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
      * 虚引用的作用是能在这个对象被收集器回收时收到一个系统通知。
  * 生存还是死亡
    * 一个对象的真正的死亡，至少要经历两次标记过程：
      * 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
      * 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指由虚拟机会触发这个方法，并不会承诺会等待它运行结束。
      * finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记。如果对象要在finalize()方法中成功拯救自己--只要重新与引用链上的任何一个对象建立关联即可。
  * 回收元空间参考一下链接
    * https://blog.csdn.net/zhushuai1221/article/details/52122880
    * 为什么从永久带转换为元空间
      * 字符串存在永久代中，容易出现性能问题和内存溢出。
      * 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
      * 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
      * Oracle 可能会将HotSpot 与 JRockit 合二为一。
### 垃圾回收算法
  * 标记-清除算法
    * 思路：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程用的是可达性分析算法来实现。
    * 缺点：标记和清除两个过程的效率都不高；标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
  * 复制算法
    * 复制算法是为了解决效率问题。
    * 思路：它将可用内存按容量大小分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
    * 优点：每次对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针即可。
    * 缺点：
      * 将内存缩小为原来的一半。
      * 在对象存活率较高时就要进行较多的复制操作，效率将会变低。
      * 需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况。
    * IBM研究表明，新生代的对象98%是“朝生夕死”的，所以并不需要按照1：1的来划分内存空间。将内存分为一块交大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor。当Survivor不够用时，需要依赖其他内存进行担保。
  * 标记-整理算法
    * 标记-整理算法过程仍然与“标记-清楚“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
  * 分代收集算法
    * 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。
    * 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制就可以完成收集。
    * 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。
### HotSpot的算法实现
  * 枚举根节点
    * 可作为GCRoots的节点主要在全局性的引用与执行上下文中。
    * 在HotSpot实现中，是使用一组称为OopMap的数据结构来实现来达到准确式GC这个目的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。
      * OopMap{ebx=Oop [16]=Oop off=142}
  * 安全点
    * 我们不可能为每一条指令都生成OopMap，因此只在“特定的位置”记录这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停。
    * 安全点的选定基本上是以指令”是否具有让程序长时间执行的特征“为标准进行选定的。”长时间执行“的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等。
    * 对于安全点需要考虑的一个问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都”跑“到最近的安全点上再停顿下来。这里有两种方案可供选择：
      * 抢先式中断：抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它”跑“到安全点上。
      * 主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询的标志的地方和安全点是重合的，另外加上创建对象需要分配内存的地方。
  * 安全区域
    * 当线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM也不太可能等待线程重新被CPU分配时间。因此需要安全区域（Safe Region）来解决。
    * 安全区域是指在一端代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。
    * 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。在线程离开Safe Region时，它要检查系统是否已经完成了根枚举（或者是整个GC过程）。如果未完成，必须等待直到收到可以安全离开Safe Region的信号未知。
### 垃圾收集器
  * 新生代收集基本上用的都是复制算法。
  * Serial 收集器
    * Serial不仅仅说明它只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
    * Serial收集器是是在Client模式下的默认新生代收集器。
    * Serial收集器可以与CMS收集器配合工作。
  * ParNew 收集器
    * ParNew收集器是Serial收集器的多线程版本。
    * ParNew收集器是Server模式下的首选的新生代收集器。
    * ParNew收集器可以与CMS收集器配合工作。
  * Parallel Scavenge 收集器
    * Parallel Scavenge收集器的目的标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。
    * Parallel Scavenge收集器打开UseAdapiveSizePolicy参数后，就不需要手工指定新生代的大小、Eden与Survivor的比例，晋升老年代对象大小等细节参数，虚拟机会更根据当前系统的运行情况收集性能监控信息，动态调整这些参数。
  * Serial Old 收集器
    * 单线程收集器。
    * 基于标记整理算法。
    * 给Client模式下的虚拟机使用。
    * 在Server模式下，有两大用途：
      * 在Jdk1.5一圈与Parallel Scavenge收集器搭配使用。
      * 作为CMS收集器的后备预案，并在并发收集发生Concurrent Mode Failure时使用。
  * Parallel Old 收集器
    * 多线程收集器。
    * 基于标记整理算法。
    * 与Parallel Scavenge收集器组合使用，在注重吞吐量以及CPU资源敏感的场合，优先考虑。
  * CMS 收集器
    * 以获取最短回收停顿时间为目标的收集器
    * 基于标记清楚算法
    * 整个过程分为四个步骤：
      * 初始标记（CMS initial mark）“stop the word"
      * 并发标记（CMS concurrent mark） 
      * 重新标记（CMS remark）“stop the word"
      * 并发清除（CMS concurrent sweep）
    * 初始标记仅仅只是标记GCRoots能 直接 关联到的对象，速度很快。（时间短）
    * 并发标记就是进行GC Roots Tracing的过程。（时间长）
    * 重新标记阶段是为了修正并发期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。（时间比GC Root Tracing短）
    * 耗时最长的并发标记和并发清除剁成收集器都可以与用户线程一起工作。
    * 缺点：
      * CMS收集器对CPU资源非常敏感。
        * CMS默认启动的回收线程数是（CPU数量+3）/ 4。当CPU数量四个以上的时候，并发回收时垃圾收集线程不少于25%的CPU资源，并随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就变得很大。
        * 虚拟机提供了一种称为”增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器。模拟多任务机制，并发标记和并发清理的时候让GC线程、用户线程交替运行。（目前已经不被提倡使用）。
      * CMS收集器无法处理浮动垃圾（Floating Carbage）。
        * CMS无法处理浮动垃圾。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行会有新的垃圾产生。
        * 这一部分的垃圾只好留待下一次GC时清理。因此需要预留一部分空间提供并发收集时的程序使用。
        * 当无法预留的内存无法满足程序需要时，就会出现一次“Concurrent Mode Failure"失败，随后将会临时启用Serial Old收集器来重新进行老年代垃圾收集。
      * CMS是一款基于”标记-清楚“算法实现的收集器，收集结束时会有大量空间碎片产生。
        * 因此提供开关参数，用于是否要在FullGC是是否要压缩。
  * G1 收集器
    * 特点：
      * 并行与并发
      * 分代收集
        * 不需要其他收集器配合就能独立管理整个GC堆。
      * 空间整合
        * G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现。
      * 可预测的停顿
        * G1除了降低停顿时间外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
    * 其他收集器收集的范围都是整个新生代或者老年代。G1将整个Java堆划分为多个大小独立的区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。
    * G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。
    * 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描。
    * G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference类型引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用的对象引用了新生代中的对象）
      * 如果是，便通过CardTable把相关引用信息记录到被引对象的Region的Remembered Set之中。
    * 如果过不计算维护Remembered Set的操作，G1收集器的运作大致分为以下几个步骤：
      * 初始标记（Initial Marking）
        * 初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top Mark Start）的指，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。
      * 并发标记（Concurrent Marking) 
        * 并发阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。
      * 最终标记 (Final Marking)
        * 最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分记录，虚拟机将这段时间变化记录在线程Remembered Set logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这个阶段需要停顿线程，但是可以并行执行。
      * 筛选回收 (Live Data Counting and Evacuation)
        * 首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。
    * 如果应用追求低停顿，那G1已经可以作为一个可尝试的选择，如果你的引用追求吞吐量，那G1并不会为你带来特别的好处。（引用自StackOverflow.com）
### 内存分配与回收策略
  * 对象优先在Eden分配
  * 大对象直接进入老年代
    * 写程序的时候应该避免生成”朝生夕灭“的”短命大对象“
  * 长期存活的对象进入老年代
    * 虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.
    * 对象在Survivor区中没“熬过”一次Minor GC，年龄就加一。当他的年龄增加到一定程度后（默认15岁），将会晋升到老年代中。
  * 动态对象年龄判断
    * 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大雨或等于该年龄对象就可以直接进入老年代，无须等到MaxTenuringThreshold要求的年龄。
  * 空间分配担保
    * 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大雨新生代所有对象总空间。
      * 如果这个条件成立，那么Minor GC可以确保是安全的。
      * 如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。
        * 如果允许，那么会检查来年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。
          * 如果大于，将尝试着进行一次Minor GC。
          * 如果小于，这时改为进行一次Full GC。
        * 如果不允许，这时改为进行一次Full GC。