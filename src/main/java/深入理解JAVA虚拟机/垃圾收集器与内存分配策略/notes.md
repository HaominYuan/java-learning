### 概述
  * 当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：
    * 哪些内存需要回收？
    * 什么时候回收？
    * 如何回收？
  * 在Java中，程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；这几个区域内就不需要过多考虑回收的问题。
  * Java堆和元空间这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。
### 对象已死吗
  * 引用计数算法
    * 思路：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就会减1；任何时刻计数器为0的对象就是不可能再被使用的。
    * 在主流的Java虚拟机里面没有选用引用计算算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
  * 可达性分析算法
    * 思路：通过一系列的称为“GC Roots”的对象做为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
    * 在Java语言中，可作为GC Roots的对象包括下面几种：
      * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
      * 元空间中类静态属性引用的对象。
      * 元空间中常量引用的对象。
      * 本地方法栈中JNI（即一般说的Native方法）引用对象。
  * 再谈引用
    * 引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减弱。
      * 强引用就是指在程序中普遍存在的，类似“Object obj = new Object()"这类的引用，只要强引用存在，垃圾回收器永远不会回收掉被引用的对象。
      * 软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发出内存溢出异常之前，将会把这些对象列出回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出溢出异常。
      * 弱引用也是用来描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
      * 虚引用的作用是能在这个对象被收集器回收时收到一个系统通知。
  * 生存还是死亡
    * 一个对象的真正的死亡，至少要经历两次标记过程：
      * 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
      * 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指由虚拟机会触发这个方法，并不会承诺会等待它运行结束。
      * finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记。如果对象要在finalize()方法中成功拯救自己--只要重新与引用链上的任何一个对象建立关联即可。
  * 回收元空间参考一下链接
    * https://blog.csdn.net/zhushuai1221/article/details/52122880
    * 为什么从永久带转换为元空间
      * 字符串存在永久代中，容易出现性能问题和内存溢出。
      * 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
      * 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
      * Oracle 可能会将HotSpot 与 JRockit 合二为一。
### 垃圾回收算法
  * 标记-清除算法
    * 思路：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程用的是可达性分析算法来实现。
    * 缺点：标记和清除两个过程的效率都不高；标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
  * 复制算法
    * 复制算法是为了解决效率问题。
    * 思路：它将可用内存按容量大小分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
    * 优点：每次对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针即可。
    * 缺点：
      * 将内存缩小为原来的一半。
      * 在对象存活率较高时就要进行较多的复制操作，效率将会变低。
      * 需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况。
    * IBM研究表明，新生代的对象98%是“朝生夕死”的，所以并不需要按照1：1的来划分内存空间。将内存分为一块交大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor。当Survivor不够用时，需要依赖其他内存进行担保。
  * 标记-整理算法
    * 标记-整理算法过程仍然与“标记-清楚“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
  * 分代收集算法
    * 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。
    * 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制就可以完成收集。
    * 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。
### HotSpot的算法实现
  * 枚举根节点
    * 可作为GCRoots的节点主要在全局性的引用与执行上下文中。
    * 在HotSpot实现中，是使用一组称为OopMap的数据结构来实现来达到准确式GC这个目的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来。在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。
      * OopMap{ebx=Oop [16]=Oop off=142}
  * 安全点
    * 我们不可能为每一条指令都生成OopMap，因此只在“特定的位置”记录这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停。
    * 安全点的选定基本上是以指令”是否具有让程序长时间执行的特征“为标准进行选定的。”长时间执行“的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等。
    * 对于安全点需要考虑的一个问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都”跑“到最近的安全点上再停顿下来。这里有两种方案可供选择：
      * 抢先式中断：抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它”跑“到安全点上。
      * 主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询的标志的地方和安全点是重合的，另外加上创建对象需要分配内存的地方。
  * 安全区域
    * 当线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM也不太可能等待线程重新被CPU分配时间。因此需要安全区域（Safe Region）来解决。
    * 安全区域是指在一端代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。
    * 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。在线程离开Safe Region时，它要检查系统是否已经完成了根枚举（或者是整个GC过程）。如果未完成，必须等待直到收到可以安全离开Safe Region的信号未知。
### 垃圾收集器
  * 新生代收集基本上用的都是复制算法。
  * Serial 收集器
    * Serial不仅仅说明它只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
    * Serial收集器是是在Client模式下的默认新生代收集器。
    * Serial收集器可以与CMS收集器配合工作。
  * ParNew 收集器
    * ParNew收集器是Serial收集器的多线程版本。
    * ParNew收集器是Server模式下的首选的新生代收集器。
    * ParNew收集器可以与CMS收集器配合工作。
  * Parallel Scavenge 收集器
    * Parallel Scavenge收集器的目的标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。
    * Parallel Scavenge收集器打开UseAdapiveSizePolicy参数后，就不需要手工指定新生代的大小、Eden与Survivor的比例，晋升老年代对象大小等细节参数，虚拟机会更根据当前系统的运行情况收集性能监控信息，动态调整这些参数。
  * Serial Old 收集器
    * 单线程收集器。
    * 基于标记整理算法。
    * 给Client模式下的虚拟机使用。
    * 在Server模式下，有两大用途：
      * 在Jdk1.5一圈与Parallel Scavenge收集器搭配使用。
      * 作为CMS收集器的后备预案，并在并发收集发生Concurrent Mode Failure时使用。
  * Parallel Old 收集器
    * 多线程收集器。
    * 基于标记整理算法。
    * 与Parallel Scavenge收集器组合使用，在注重吞吐量以及CPU资源敏感的场合，优先考虑。
  * CMS 收集器
    * 以获取最短回收停顿时间为目标的收集器
    * 基于标记清楚算法
    * 整个过程分为四个步骤：
      * 初始标记（CMS initial mark）“stop the word"
      * 并发标记（CMS concurrent mark） 
      * 重新标记（CMS remark）“stop the word"
      * 并发清除（CMS concurrent sweep）
    * 初始标记仅仅只是标记GCRoots能 直接 关联到的对象，速度很快。（时间短）
    * 并发标记就是进行GC Roots Tracing的过程。（时间长）
    * 重新标记阶段是为了修正并发期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。（时间比GC Root Tracing短）
    * 耗时最长的并发标记和并发清除剁成收集器都可以与用户线程一起工作。
    * 缺点：
      * CMS收集器对CPU资源非常敏感。
        * CMS默认启动的回收线程数是（CPU数量+3）/ 4。当CPU数量四个以上的时候，并发回收时垃圾收集线程不少于25%的CPU资源，并随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就变得很大。
        * 虚拟机提供了一种称为”增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器。模拟多任务机制，并发标记和并发清理的时候让GC线程、用户线程交替运行。（目前已经不被提倡使用）。
      * CMS收集器无法处理浮动垃圾（Floating Carbage）。
        * CMS无法处理浮动垃圾。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行会有新的垃圾产生。
        * 这一部分的垃圾只好留待下一次GC时清理。因此需要预留一部分空间提供并发收集时的程序使用。
        * 当无法预留的内存无法满足程序需要时，就会出现一次“Concurrent Mode Failure"失败，随后将会临时启用Serial Old收集器来重新进行老年代垃圾收集。
      * CMS是一款基于”标记-清楚“算法实现的收集器，收集结束时会有大量空间碎片产生。
        * 因此提供开关参数，用于是否要在FullGC是是否要压缩。
  * G1 收集器
    * 