### 概述
  * 越来越多的程序语言选择了与操作系统和极其指令集无关的、平台中立的格式作为程序编译后的储存格式。
### 无关的基石
  * 实现语言无关性的基础是虚拟机和字节码储存格式。
  * Java虚拟机不和包含Java在内的任何语言绑定，他只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。
  * Java虚拟机规范要求在Class文件中使用强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。
  * Java虚拟机中的各种变量、关键字和运算符号的语言最终都是由多条字节码命令组合而成，因此字节码所能提供的语义描述能力比Java语言强大。因此这位其他语言实现一些有别于Java的语言特性提供基础。
### Class类文件的结构
  * Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行储存。
  * Class文件格式采用一种类似于C语言结构体的伪结构来储存数据，这种伪结构中只有两种数据类型：
    * 无符号数属于基本的数据类型
      * u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
    * 表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性地以“_info"结尾。表用于描述有层次关系的符合结构的数据，整个class文件本质就是一张表。
  * 当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。
  * 魔数与class文件的版本
    * 每个class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
    * 紧接着魔数的4个字节储存的是Class文件的版本号（Major Version）。
    * 高版本的JDK能向下兼容以前版本的Class，但不能也禁止运行以后版本的Class文件。
  * 常量池
    * 紧接着主版本号之后的是常量池入口。
    * 由于常量池中常量的数量是不确定的，所以在常量池入口放置一项u2类型的数据，代表常量池容量计数值。这个容量计数值从1开始。
    * 在特定情况下需要表示”不引用任何一个常量池项目”的含义，这种情况可以把索引值值置为零来表示。
    * 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References)。
      * 字面量包括如文本字符串、神明为final的常量值等。
      * 符号引用包括三类常量：
        * 类和接口的全限定名（Fully Qualified Name）（java/lang/String；)
        * 字段的名称和描述符（Descriptor）
        * 方法的名称和描述符
     * Java代码在进行javac编译的时候，没有“连接”这一步骤，而是在虚拟机加载Class文件的时候动态连接。
    * 常量池中每一项常量都是一个表。
      * 表开始的第一位是一个u1类型的标志位。
    * 由于Class文件中方法、字段都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。最大长度就是length中的最大值65535。
  * 访问标志
    * 常量池结束之后，紧接着的两个字节代表访问（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。
  * 类索引、父类索引与接口索引集合
    * 类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。
    * 父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父亲索引都不为0。
    * 接口索引集合用来描述这个类实现了哪些接口。
      * 索引集合第一项u2类型的数据为接口计数器表示索引表的容量。
  * 字段表集合
    * 字段表（field_info)用于接口或者类中声明的变量。字段包含类级变量以及实例级变量。可包含的信息有：
      * 字段的作用域（public、private、protected）
      * 实例变量还是类变量（static修饰符）
      * 可变性（final）
      * 并发可见性（volatie修饰符，是否强制从主内存读写）
      * 是否被序列化（transient修饰符）
      * 字段数据类型（基本类型、对象、数组）
      * 字段名称
    * 修饰符都是布尔类型，适合使用标志位来表示。字段名和字段类型只能引用常量池中的常量来描述。
    * 字段修饰符放在access_flags项目中，与类中的access_flags相似。
    * 跟随着access_flags标志的是两项索引值：name_index和descriptor_index分别代表着字段的简单名称和描述符。
      * 形如java/lang/String这类为全限定名，在使用时最后一般会加入“；”表示全限定名结束。
      * 简单名称是指没有类型和参数修饰的方法或者字段名称，例如void func(Object obj) 其中func就是简单名称。
      * 描述符的作用是用来描述字段的数据类型、方法的参数列表（数量、类型以及顺序）和返回值。
        * 在descriptor_index之后跟随这一个属性表集合用于储存一些额外的信息。例如
          * final static int m = 123;
    * 字段表不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段。
    * 在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都不需要使用不一样的名称，但是对于字节码来说将，如果两个字段的描述符不一致，那字段重名就是合法的。
  * 方法表集合
    * 方法的描述与对字段的描述几乎采用了完全一致的方法。
    * 方法里的Java代码，经过编译器编译成字节码后，存放在方法属性表集合中一个名为“Code”的属性里面。
    * 如果父类方法在子类中没有被重写（Override），方法表中就不会出现来自父类的方法信息。但有可能出现由编译器自动添加的方法。例如：类构造器<clinit>和实例构造器<init>
    * 在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。
      * 特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载。
    * 在Class文件格式中返回值包括在特征签名签名中，因此返回值不同也是可以合法共存于同一个class文件中。
  * 属性表集合
    * 每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。
    * Code属性
      * Java方法体中的代码经过Javac编译器处理后，最终变为字节码指令储存在Code属性内。
      * 