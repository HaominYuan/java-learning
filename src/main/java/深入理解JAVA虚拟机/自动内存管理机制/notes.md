### 概述
  * Java不需要为每一个new操作去写配对的delete/free代码
- - -
### 运行时数据区域
  * 程序计数器
    * 程序计数器是一块较小的内存空间。字节码解释工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
    * Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。因此，每条线程都需要有一个独立的程序程序计数器。各条线程之间计数器互不影响，独立储存。
    * 如果执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如公示Native方法，这个计数器值为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
  * Java虚拟机栈
    * Java虚拟机栈是线程私有的，它的生命周期与线程相同。
    * 每个方法执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到岀栈的过程。
    * 局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double），对象引用(reference类型，他不等于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型（指向了一条字节码指令的地址）。
    * 64位float和double类型的数据会占用2个局部变量空间（slot），其余占一个。局部变量空间在编译期间完成分配，运行期不会改变局部变量表的大小。
  * 本地方法栈
    * 在虚拟机规范中对本地方法栈中方法使用的语言、使用的方法与数据结构并没有强制规定。
    * 本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
  * Java堆
    * Java堆是被所有线程共享的一块内存区域。
    * 几乎所有的对象实例都在这里分配。因为JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术导致一些微妙的变化发生。因此是几乎所有对象，而不是全部。
    * Java堆在物理上不连续的内存空间中，只要逻辑上是连续即可。
  * 方法区
    * 在Java8已经被移除。
  * 元空间
    * 储存方法代码、方法数据、常量池等信息。
    * 用的是Native Memory空间。
    * 内存空间不够用时会发生OutOfMemoryError。
    * 待补充
  * 常量池
    * 储存字面量和符号引用量。
  * 直接内存
    * 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存可以被频繁使用，可能造成OutOfMemoryError。
    * 在JDK1.4中新加入了NIO类，引入一种基于通道（channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个储存在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样可以避免在Java堆和Native堆中来回复制数据。
- - -
### HotSpot虚拟机对象探秘
  * 对象的建立（仅讨论普通对象，不考虑数组和Class对象）
    * 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用的类是否已经被加载、解析和初始化过。如果没有将会进行执行相应的类加载过程。
    * 类加载检查通过后，接下来为新生对象分配内存。对象所需内存的大小在类加载玩后便完全确定，为对象分配内存空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
    * 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的放在另一边，这种放着一个i额指针作为分界点的指示器，那分配内存仅仅是把那个指针向空闲空间那边挪移一段与对象大小相等的距离。
    * 如果Java堆中的内存不是规整的，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
    * Java堆是否规整又由所从用的垃圾搜集器是否带有压缩整理功能决定。